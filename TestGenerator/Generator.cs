using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using RhoMicro.CodeAnalysis;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Xml.Linq;

namespace TestGenerator
{
    [Generator]
    public class Generator : ISourceGenerator
    {
        private static Namespace AttributesNamespace = Namespace.Create<ObjectSync.Attributes.SynchronizedAttribute>();

        private static TypeIdentifierName SynchronizedAttributeName = TypeIdentifierName.CreateAttribute<ObjectSync.Attributes.SynchronizedAttribute>();
        private static TypeIdentifierName SynchronizationIdAttributeName = TypeIdentifierName.CreateAttribute<ObjectSync.Attributes.SynchronizationIdAttribute>();
        private static TypeIdentifierName SynchronizationAuthorityAttributeName = TypeIdentifierName.CreateAttribute<ObjectSync.Attributes.SynchronizationAuthorityAttribute>();

        private static TypeIdentifier SynchronizedAttributeIdentifier = TypeIdentifier.Create(SynchronizedAttributeName, AttributesNamespace);
        private static TypeIdentifier SynchronizationIdAttributeIdentifier = TypeIdentifier.Create(SynchronizationIdAttributeName, AttributesNamespace);
        private static TypeIdentifier SynchronizationAuthorityIdentifier = TypeIdentifier.Create(SynchronizationAuthorityAttributeName, AttributesNamespace);

        private const String SYNCHRONIZATION_ID_FALLBACK_NAME = "__SynchronizationId";
        private const String SYNCHRONIZED_PROPERTY_PREFIX = "Synchronized";

        public void Execute(GeneratorExecutionContext context)
        {
            var analyzer = new CompilationAnalyzer(context.Compilation);

            var synchronizedTypes = GetSynchronizedTypes(analyzer);

            foreach (var synchronizedType in synchronizedTypes)
            {
                var source = GetSource(synchronizedType, analyzer);

                var generatedSource =
$@"// <auto-generated/>
//{DateTimeOffset.Now}
{source}";

                var hintName = $"{analyzer.GetTypeIdentifier(synchronizedType).Name}.g.cs";

                context.AddSource(hintName, generatedSource);
            }
        }

        public void Initialize(GeneratorInitializationContext context)
        {

        }

        private static IEnumerable<BaseTypeDeclarationSyntax> GetSynchronizedTypes(CompilationAnalyzer analyzer)
        {
            return analyzer.GetTypeDeclarations().Where(td => analyzer.GetFieldDeclarations(td, include: new[] { SynchronizedAttributeIdentifier }).Any());
        }

        private String GetSource(BaseTypeDeclarationSyntax synchronizedType, CompilationAnalyzer analyzer)
        {
            try
            {
                var synchronizedTypeIdentifier = analyzer.GetTypeIdentifier(synchronizedType);

                var authorityProperties = analyzer.GetPropertyDeclarations(synchronizedType, new[] { SynchronizationAuthorityIdentifier });
                if (authorityProperties.Count() > 1)
                {
                    throw new Exception($"Multiple properties annotated with {SynchronizationAuthorityIdentifier} have been declared in {synchronizedTypeIdentifier}.");
                }

                var authorityProperty = authorityProperties.SingleOrDefault();
                if (authorityProperty == null)
                {
                    throw new Exception($"A property annotated with {SynchronizationAuthorityIdentifier} must be declared in {synchronizedTypeIdentifier}.");
                }

                var authorityName = authorityProperty.Identifier.Text;

                var synchronizedFields = analyzer.GetFieldDeclarations(synchronizedType, new[] { SynchronizedAttributeIdentifier });

                var properties = new List<String>();

                var synchronizationId = analyzer.GetPropertyDeclarations(synchronizedType, new[] { SynchronizationIdAttributeIdentifier }).SingleOrDefault();
                var synchronizationIdName = synchronizationId?.Identifier.Text;

                foreach (var field in synchronizedFields)
                {
                    var property = GetSynchronizedProperty(field, authorityName, synchronizationIdName, analyzer);
                    properties.Add(property);
                }

                var propertiesString = String.Concat(properties.Select(p => $"\n\n\t{p}"));
                var synchronizationIdProperty = String.IsNullOrEmpty(synchronizationIdName) ? $"private String {SYNCHRONIZATION_ID_FALLBACK_NAME} {{get; }} = Guid.NewGuid().ToString();" : String.Empty;

                var visibility = synchronizedType.Modifiers.Where(t => t.IsKind(SyntaxKind.PublicKeyword) || t.IsKind(SyntaxKind.InternalKeyword) || t.IsKind(SyntaxKind.PrivateKeyword))
                    .SingleOrDefault().Text;

                visibility = String.IsNullOrEmpty(visibility) ? "private" : visibility;

                var partialClassSource =
    $@"namespace {synchronizedTypeIdentifier.Namespace}
{{
    {visibility} partial class {synchronizedTypeIdentifier.Name} : IDisposable
    {{
        {synchronizationIdProperty}{String.Concat(propertiesString)}

        partial void DisposeManagedResources();
        partial void DisposeUnmanagedResources();

	    private void Dispose(Boolean disposing)
	    {{
		    if (!disposedValue)
		    {{
			    if (disposing)
			    {{
				    DisposeManagedResources();
			    }}

			    DisposeUnmanagedResources();
			    disposedValue = true;
		    }}
	    }}

	    ~MySynchronizedObject()
	    {{
	        Dispose(disposing: false);
	    }}

	    public void Dispose()
	    {{
		    Dispose(disposing: true);
		    GC.SuppressFinalize(this);
	    }}
    }}
}}";

                return partialClassSource;
            }
            catch (Exception ex)
            {
                return
$@"/*    
An exception occured while generating code for {analyzer.GetTypeIdentifier(synchronizedType)}:
{ex}
*/";
            }
        }

        private String GetSynchronizedProperty(FieldDeclarationSyntax field, String authorityName, String synchronizationIdName, CompilationAnalyzer analyzer)
        {
            var fieldType = analyzer.GetTypeIdentifier(field.Declaration.Type);
            var propertyName = GetSynchronizedPropertyName(field, analyzer);
            var fieldName = field.Declaration.Variables.Single().Identifier.Text;
            synchronizationIdName = String.IsNullOrEmpty(synchronizationIdName) ? SYNCHRONIZATION_ID_FALLBACK_NAME : synchronizationIdName;

            var property =
$@"public {fieldType} {propertyName} 
	{{
	    get
		{{
			return {fieldName};
		}}
		set
		{{
			{fieldName} = value;
			{authorityName}.Push<{fieldType}>({synchronizationIdName}, {propertyName}, value);
		}}
	}}
";

            return property;
        }

        private static String GetSynchronizedPropertyName(FieldDeclarationSyntax field, CompilationAnalyzer analyzer)
        {
            analyzer.TryGetAttributes(field.AttributeLists, field, SynchronizedAttributeIdentifier, out var attributes);

            var propertyName = attributes.Single()
                .ArgumentList?
                .DescendantNodes(d => d.IsKind(SyntaxKind.StringLiteralExpression))
                .SingleOrDefault()?.ToString();

            if (String.IsNullOrEmpty(propertyName))
            {
                var fieldName = field.Declaration.Variables.Single().Identifier.Text;
                propertyName = fieldName.StartsWith("_") ?
                    $"\"{SYNCHRONIZED_PROPERTY_PREFIX}{fieldName}\"" :
                    $"\"{SYNCHRONIZED_PROPERTY_PREFIX}_{fieldName}\"";
            }
            return propertyName;
        }
    }
}
