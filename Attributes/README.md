# ObjectSync.Attributes #

This assembly contains attributes that mark targets for source generation by the ObjectSync.Generator.

## Features ##

* Mark fields for synchronized property generation
* Mark properties as the synchronization authority
* Mark properties as the synchronization instance id
* Mark synchronized fields for event method generation (OnPropertyChanged/OnPropertyChanging support)

## Versioning ##

ObjectSync.Attributes uses [Semantic Versioning 2.0.0](https://semver.org/).

## Installation ##

Nuget Gallery: https://www.nuget.org/packages/RhoMicro.ObjectSync.Attributes

Package Manager: `Install-Package RhoMicro.ObjectSync.Attributes -Version 1.0.0`

.Net CLI: `dotnet add package RhoMicro.ObjectSync.Attributes --version 1.0.0`

## How To Use ##

Synchronized types must be partial.

In order to provide the ObjectSync.Generator with the most basic instructions, three steps are necessary:

* Mark any number of fields as synchronized
* Mark a property as the synchronization authority
* Call `GetSynchronizationState().Synchronize()` during the object initialization phase

### Marking A Field As Synchronized ###

A field must be annotated using `SynchronizedAttribute` in order for the ObjectSync.Generator to generate a synchronized property for it.

```cs
[Synchronized]
private String? _name;
```

Note that the ObjectSync.Generator will recognize two naming conventions for field identifiers starting with:
* any number of prefixed underscores
* a lower case letter

In these cases, the ObjectSync.Generator will generate a simple uppercase version of the field identifier, with underscores omitted.

Should the marked field not meet one of the conditions outlined above, the generated property will be name using the original field identiifer prefixed by `Synchronized`.

You can also provide a name for the property generated by setting the attribute parameter.

```cs
[Synchronized("CustomName")]
private String? _name;
```
*Note that using a named argument here is not currently supported.*

### Marking A Property As The Synchronization Authority ###

A property must be annotated using `SynchronizationAuthorityAttribute` in order to enable the ObjectSync.Generator to generate synchronization logic.

```cs
[SynchronizationAuthority]
private ISynchronizationAuthority Authority { get; } = StaticSynchronizationAuthority.Instance;
```

The type returned by this property must provide the following method signatures:

```cs
TProperty Pull<TProperty>(String typeId, String propertyName, String sourceInstanceId, String instanceId);

void Push<TProperty>(String typeId, String propertyName, String sourceInstanceId, String instanceId, TProperty value);

void Subscribe<TProperty>(String typeId, String propertyName, String sourceInstanceId, String instanceId, Action<TProperty> callback);

void Unsubscribe(String typeId, String propertyName, String sourceInstanceId, String instanceId);
```

For more details on synchronization authorities, consult the [ObjectSync.Synchronization readme](https://github.com/PaulBraetz/ObjectSync/Synchronization).

### Calling `GetSynchronizationState().Synchronize()` During The Object Initialization Phase ###

The ObjectSync.Generator will generate a synchronization context type for instances of your type that will provide the following members:

```cs
Boolean IsSynchronized { get; private set;}

void Synchronize();

void Desynchronize();

void Invoke(Action whenSynchronized, Action whenDesynchronized);
```

It will also generate a property `SynchronizationContext` for accessing an instance of this type that corresponds to the instance from which it is accessed.

`SynchronizationContext.IsSynchronized` will be true when the corresponding instance is synchronized to it's authority.

Calling `SynchronizationContext.Synchronize()` will synchronize your object to the state provided by the synchronization authority.
Any changes to synchronized properties on this or other synchronized instances will be reflected in all of them.

Calling `SynchronizationContext.Desynchronize()` will desynchronize your instance from other synchronized instances; it will be decoupled again.

You may, for example, call `SynchronizationContext.Synchronize()` during the initialization of your object:

```cs
public Person(String name)
{
	SynchronizationContext.Synchronize();
	Name = name;
}
```

For scenarios in which the synchronization authority has an extended lifespan, implementing the `IDisposable` [pattern](https://docs.microsoft.com/en-us/dotnet/api/system.idisposable?view=net-6.0) on your type is recommended:

```cs
protected virtual void Dispose(bool disposing)
{
    if(!this.disposed)
    {
        if(disposing)
        {
            SynchronizationContext.Desynchronize();
        }

        disposed = true;
    }
}
```

Calling `SynchronizationContext.Invoke(Action, Action)` will enable you to synchronize sections of code with synchronization state changes.
For example, the method is used in generated setters in order to avoid unnecessary calls to the authority's `.Push`-method.
The methods first argument will only be invoked when `SynchronizationContext.IsSynchronized` is true, whereas the second parameter will only be invoked when `SynchronizationContext.IsSynchronized`is false.
The comparisons involved here will be executed inside a lock statement that is aquired on a private `_syncRoot`.
`SynchronizationContext.Desynchronize()` and `SynchronizationContext.Synchronize()` are also executed by aquiring a lock on `_syncRoot`, thereby synchronizing all three invocations.
Whilst this lock guarantees the correct execution of the three methods, it is a bottleneck on setter invocations.

***Therefore, you should ensure an authorization strategy that synergizes well with the types and amount of synchronized properties in your application.***

- - - -

## Additional Instructions ##

### Provide A Type Id ###

Every synchronizable type must be uniquely identifiable in order to manage synchronization subscriptions.
The type id should be 
* unique to the synchronized type
* immutable.
Therefore, a static, readonly property is well suited for providing the type id.
If not explicitly specified, a static property will be generated.

It will look something like this:

```cs
private static System.String TypeId { get; } = Guid.NewGuid.ToString();
```

You may explicitly provide this property yourself using the `TypeIdAttribute`:

```cs
[TypeId]
private String TypeId { get; } = typeof(Person).FullName;
```

### Provide A Source Instance Id ###

Instances sharing a source instance id will be synchronized. You may regard it as a group id.

For scenarios where an instance's group is unique to the instance and may change, the source instance id should be
* non-static
* read/write

For scenarios where an instance's group is unique to the instance and may not change, the source instance id should be
* non-static
* readonly.

For scenarios where an instance's group is shared among all other instances of the type and may change, the source instance id should be
* static
* read/write.

For scenarios where an instance's group is shared among all other instances of the type and may not change, the source instance id should be
* static
* readonly.

If not explicitly specified, a non-static, read/write property will be generated.

It will look something like this:

```cs
private System.String SourceInstanceId { get; set; } = Guid.NewGuid.ToString();
```

You may explicitly provide this property yourself using the `SourceInstanceIdAttribute`:

```cs
[SourceInstanceId]
private static String SourceInstanceId { get; } = Guid.NewGuid().ToString();
```
*This source instance id will cause all instances of this type to be synchronized.*

### Provide An Instance Id ###

Every synchronized instance must be uniquely identifiable in order to manage synchronization subscriptions.

The instance id should be 
* unique to the synchronized instance
* immutable.

Therefore, a non-static, readonly property is well suited for providing the instance id.
If not explicitly specified, a property will be generated.

It will look something like this:

```cs
private System.String InstanceId { get; } = System.Guid.NewGuid().ToString();
```

You may explicitly provide this property yourself using the `InstanceIdAttribute`:

```cs
[InstanceId]
private String InstanceId { get; } = Random.Shared.Next().ToString();
```

### Generate Observe Methods ###

You may instruct the ObjectSync.Generator to generate partial methods for reacting to property changes using the `ObserveAttribute`.
Simply apply it to every field whose generated property you wish to observe when changing or changed:

```cs
[Observe]
private String? _name;
```

Note that applying the `SynchronizedAttribute` is not required for this to work.

Then provide implementations for the generated partial methods, implementing `INotifyPropertyChanged` and `INotifyPropertyChanging`, for example:

```cs
public event PropertyChangedEventHandler? PropertyChanged;
partial void OnPropertyChanged(String propertyName)
{
	PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
}

public event PropertyChangingEventHandler? PropertyChanging;
partial void OnPropertyChanging(String propertyName)
{
	PropertyChanging?.Invoke(this, new PropertyChangingEventArgs(propertyName));
}
```
