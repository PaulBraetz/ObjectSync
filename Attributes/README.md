# ObjectSync.Attributes #

This assembly contains attributes that mark targets for source generation by the ObjectSync.Generator.

## Features ##

* Mark fields for synchronized property generation
* Mark properties as the synchronization authority
* Mark properties as the synchronization instance id
* Mark synchronized fields for event method generation (OnPropertyChanged/OnPropertyChanging support)

## Versioning ##

ObjectSync.Attributes uses [Semantic Versioning 2.0.0](https://semver.org/).

## Installation ##

Nuget Gallery: https://www.nuget.org/packages/RhoMicro.ObjectSync.Attributes

Package Manager: `Install-Package RhoMicro.ObjectSync.Attributes -Version 1.0.0`

.Net CLI: `dotnet add package RhoMicro.ObjectSync.Attributes --version 1.0.0`

## How To Use ##

Synchronized types must be partial.

In order to provide the ObjectSync.Generator with the most basic instructions, three steps are necessary:

* Mark any number of fields as synchronized
* Mark a property as the synchronization authority
* Call 'GetSynchronizationState().Synchronize()' during the object initialization phase

### Marking A Field As Synchronized ###

A field must be annotated using 'SynchronizedAttribute' in order for the ObjectSync.Generator to generate a synchronized property for it.

'''cs
[Synchronized]
private String? _name;
'''

The property generated by the ObjectSync.Generator will look something like this:

'''cs
public System.String Name 
{
	get
	{
		return _name;
	}
	set
	{
		SetAndPushName(value);
	}
}
'''

Note that the ObjectSync.Generator will recognize two naming conventions for field identifiers starting with:
* any number of prefixed underscores
* a lower case letter

In these cases, the ObjectSync.Generator will generate a simple uppercase version of the field identifier, with underscores omitted.

Should the marked field not meet one of the conditions outlined above, the generated property will be name using the original field identiifer prefixed by 'Synchronized'.

You can also provide a name for the property generated by setting the attribute parameter.

'''cs
[Synchronized("CustomName")]
private String? _name;
'''
*Note that using a named argument here is not currently supported.*

### Marking A Property As The Synchronization Authority ###

A property must be annotated using 'SynchronizationAuthorityAttribute' in order to enable the ObjectSync.Generator to generate synchronization logic.

'''cs
[SynchronizationAuthority]
private ISynchronizationAuthority _authority { get; } = new ();
'''

The type returned by this property must provide the following method signatures:

'''cs
TProperty Pull<TProperty>(String typeId, String propertyName, String instanceId);

void Push<TProperty>(String typeId, String propertyName, String instanceId, TProperty value);

void Subscribe<TProperty>(String typeId, String propertyName, String instanceId, Action<TProperty> callback);

void Unsubscribe(String typeId, String propertyName, String instanceId);
'''

For more details on synchronization authorities, consult the [ObjectSync.Synchronization readme](https://github.com/PaulBraetz/ObjectSync/Synchronization/README).

### Calling 'GetSynchronizationState().Synchronize()' During The Object Initialization Phase ###

The ObjectSync.Generator will generate a method 'GetSynchronizationState()' that will return a state object providing the following members:

'''cs
Boolean IsSynchronized {get;}

void Synchronize();

void Desynchronize();
'''

Calling 'GetSynchronizationState().Synchronize()' will synchronize your object to the state provided by the synchronization authority.
Any changes to synchronized fields to this or other synchronized instances will be reflected in all of them.

Calling 'GetSynchronizationState().Desynchronize()' will desynchronize your instance from other synchronized instances; it will be decoupled again.

You may, for example, call 'GetSynchronizationState().Synchronize()' during the initialization of your object:

'''cs
public Person(String name)
{
	GetSynchronizationState().Synchronize();
	Name = name;
}
'''

- - - -

## Additional Instructions ##

### Provide A Type Id ###

Every synchronizable type must be uniquely identifiable in order to manage synchronization subscriptions.
If not explicitly specified, a static property will be generated for this purpose.
Note that due to the nature of this property being an identifier unique to the type, it being static is a design choice and required by the ObjectSync.Generator.

It will look something like this:

'''cs
private static System.String TypeId { get; } = "TestApp.Person";
'''

You may explicitly provide this property yourself using the 'TypeIdAttribute':

'''cs
[TypeId]
private static String TypeId { get; } = Guid.NewGuid().ToString();
'''

### Provide An Instance Id ###

Every synchronized object must be uniquely identifiable in order to manage synchronization subscriptions.
If not explicitly specified, a property will be generated for this purpose.

It will look something like this:

'''cs
private System.String InstanceId {get;} = System.Guid.NewGuid().ToString();
'''

You may explicitly provide this property yourself using the 'InstanceIdAttribute':

'''cs
[InstanceId]
private String SyncId { get; }
'''

### Generate Events ###

You may instruct the ObjectSync.Generator to generate partial methods for use in types implementing 'INotifyPropertyChanged' or 'INotifyPropertyChanging' using the 'GenerateEventsAttribute'.
Simply apply it to every field whose generated synchronized property you wish to trigger the events when changing or changed:

'''cs
[Synchronized]
[GenerateEvents]
private String? _name;
'''

Then implement events and methods for interfacing with the generated code:

'''cs
public event PropertyChangedEventHandler? PropertyChanged;
partial void OnPropertyChanged(PropertyChangedEventArgs args)
{
	PropertyChanged?.Invoke(this, args);
}

public event PropertyChangingEventHandler? PropertyChanging;
partial void OnPropertyChanging(PropertyChangingEventArgs args)
{
	PropertyChanging?.Invoke(this, args);
}
'''
