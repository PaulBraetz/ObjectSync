# ObjectSync.Attributes #

This assembly contains attributes that mark targets for source generation by the ObjectSync.Generator.

## Features ##

* Mark fields for synchronized property generation
* Mark properties as the synchronization authority
* Mark properties as the type id
* Mark properties as the instance id
* Mark properties as the source instance id
* Mark fields for event method generation (`OnPropertyChanged`/`OnPropertyChanging`)

## Versioning ##

ObjectSync.Attributes uses [Semantic Versioning 2.0.0](https://semver.org/).

## Installation ##

Nuget Gallery: https://www.nuget.org/packages/RhoMicro.ObjectSync.Attributes

Package Manager: `Install-Package RhoMicro.ObjectSync.Attributes -Version 1.0.0`

.Net CLI: `dotnet add package RhoMicro.ObjectSync.Attributes --version 1.0.0`

## How To Use ##

Synchronized types must be partial.

In order to provide the ObjectSync.Generator with the most basic instructions, three steps are necessary:

* Mark any number of fields as synchronized
* Mark a property as the synchronization authority
* Call `SynchronizationContext.Synchronize()` during the object initialization phase

### Marking A Field As Synchronized ###

A field must be annotated using `SynchronizedAttribute` in order for the ObjectSync.Generator to generate a synchronized property for it.

```cs
[Synchronized]
private String? _name;
```

Note that the ObjectSync.Generator will recognize two naming conventions for field identifiers starting with:
* any number of underscores
* a lower case letter

In these cases, the ObjectSync.Generator will generate a simple uppercase version of the field identifier, with underscores omitted.

Should the marked field not meet one of the conditions outlined above, the generated property will be name using the original field identiifer prefixed by `Synchronized`.

You can also provide a name for the property generated by setting the attribute parameter.

```cs
[Synchronized("UserName")]
private String? _name;
```
*Note that using a named argument here is not currently supported.*

### Marking A Property As The Synchronization Authority ###

A property must be annotated using `SynchronizationAuthorityAttribute` in order to enable the ObjectSync.Generator to generate synchronization logic.

```cs
[SynchronizationAuthority]
private ISynchronizationAuthority Authority { get; } = StaticSynchronizationAuthority.Instance;
```

The type returned by this property must provide the following method signatures:

```cs
TProperty Pull<TProperty>(String typeId, String propertyName, String sourceInstanceId, String instanceId);

void Push<TProperty>(String typeId, String propertyName, String sourceInstanceId, String instanceId, TProperty value);

void Subscribe<TProperty>(String typeId, String propertyName, String sourceInstanceId, String instanceId, Action<TProperty> callback);

void Unsubscribe(String typeId, String propertyName, String sourceInstanceId, String instanceId);
```

For more details on synchronization authorities, see the [ObjectSync.Synchronization readme](https://github.com/PaulBraetz/ObjectSync/tree/master/Synchronization).

### Calling `SynchronizationContext.Synchronize()` During The Object Initialization Phase ###

The ObjectSync.Generator will generate a synchronization context type for instances of your type that will provide the following members:

```cs
Boolean IsSynchronized { get; }

event EventHandler<Boolean> SynchronizationChanged

void Synchronize();

void Desynchronize();

void Resynchronize();

void Invoke(Action<Boolean> method)

void DesynchronizeInvokeSynchronize(Action method)
```

It will also generate a property `SynchronizationContext` for accessing an instance of this type that corresponds to the instance from which it is accessed.

`SynchronizationContext.IsSynchronized` will be true when the corresponding instance is synchronized to it's authority.

`SynchronizationContext.SynchronizationChanged` will be invoked after `SynchronizationContext.IsSynchronized` changed.

Calling `SynchronizationContext.Synchronize()` will synchronize your object to the state provided by the synchronization authority.
Any changes to synchronized properties on this or other synchronized instances will be reflected in all of them.

You may, for example, call `SynchronizationContext.Synchronize()` during the initialization of your object:

```cs
public Person(String name)
{
	SynchronizationContext.Synchronize();
	Name = name;
}
```

Calling `SynchronizationContext.Desynchronize()` will desynchronize your instance from other synchronized instances; it will be decoupled again.
For scenarios in which the synchronization authority has an extended lifespan, implementing the `IDisposable` [pattern](https://docs.microsoft.com/en-us/dotnet/api/system.idisposable?view=net-6.0) on your type is recommended:

```cs
protected virtual void Dispose(bool disposing)
{
    if(!this.disposed)
    {
        if(disposing)
        {
            SynchronizationContext.Desynchronize();
        }

        disposed = true;
    }
}
```

Calling `SynchronizationContext.Resynchronize()` will desynchronize your instance if it is already synchronized and then synchronize it again.

Calling `SynchronizationContext.Invoke(Action<Boolean> method)` or `DesynchronizeInvokeSynchronize(Action method)` will enable you to synchronize sections of code with synchronization state changes.
For example, `SynchronizationContext.Invoke(Action<Boolean> method)` is used in generated setters in order to avoid unnecessary calls to the authority's `.Push`-method.
The methods argument will be passed the value of `SynchronizationContext.IsSynchronized` at the time of invocation.
All method in `SynchronizationContext` are executed by aquiring a lock on `_syncRoot`, thereby synchronizing all changes and examinations of its synchronization state.
Whilst this lock guarantees the correct execution of these methods, it is a bottleneck on setter invocations. In order to avoid this bottleneck, you may annotate synchronized fields with the `FastSynchronizedAttribute`:

```cs
[Synchronized("UserName")]
[FastSynchronized]
private String? _name;
```
*Note that the `FastSynchronizedAttribute` implies the `SynchronizedAttribute`.*

This causes the set operation not to be synchronized with other operations on `SynchronizationContext`.

- - - -

## Optional Attributes ##

### Provide A Type Id ###

Every synchronizable type must be uniquely identifiable in order to manage synchronization subscriptions.
The type id should be 
* unique to the synchronized type
* immutable.
Therefore, a static, readonly property is well suited for providing the type id.
If not explicitly specified, a static property will be generated.

It will look something like this:

```cs
private static System.String TypeId { get; } = Guid.NewGuid.ToString();
```

You may explicitly provide this property yourself using the `TypeIdAttribute`:

```cs
[TypeId]
private String TypeId { get; } = typeof(Person).FullName;
```

### Provide A Source Instance Id ###

Instances sharing a source instance id will be synchronized. You may regard it as a group id.

For scenarios where an instance's group is unique to the instance and may change, the source instance id should be
* non-static
* read/write

For scenarios where an instance's group is unique to the instance and may not change, the source instance id should be
* non-static
* readonly.

For scenarios where an instance's group is shared among all other instances of the type and may change, the source instance id should be
* static
* read/write.

For scenarios where an instance's group is shared among all other instances of the type and may not change, the source instance id should be
* static
* readonly.

If not explicitly specified, a non-static, read/write property will be generated.

It will look something like this:

```cs
private System.String SourceInstanceId { get; set; } = Guid.NewGuid.ToString();
```

You may explicitly provide this property yourself using the `SourceInstanceIdAttribute`:

```cs
[SourceInstanceId]
private static String SourceInstanceId { get; } = Guid.NewGuid().ToString();
```
*This source instance id will cause all instances of this type to be synchronized.*

### Provide An Instance Id ###

Every synchronized instance must be uniquely identifiable in order to manage synchronization subscriptions.

The instance id should be 
* unique to the synchronized instance
* immutable.

Therefore, a non-static, readonly property is well suited for providing the instance id.
If not explicitly specified, a property will be generated.

It will look something like this:

```cs
private System.String InstanceId { get; } = System.Guid.NewGuid().ToString();
```

You may explicitly provide this property yourself using the `InstanceIdAttribute`:

```cs
[InstanceId]
private String InstanceId { get; } = Random.Shared.Next().ToString();
```

### Generate Observe Methods ###

You may instruct the ObjectSync.Generator to generate partial methods for reacting to property changes using the `ObservableAttribute`.
Simply apply it to every field whose generated property you wish to observe when changing or changed:

```cs
[Observe]
private String? _name;
```

Note that applying the `SynchronizedAttribute` is not required for this to work.

Then provide implementations for the generated partial methods, implementing `INotifyPropertyChanged` and `INotifyPropertyChanging`, for example:

```cs
public event PropertyChangedEventHandler? PropertyChanged;
partial void OnPropertyChanged(String propertyName)
{
    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
}

public event PropertyChangingEventHandler? PropertyChanging;
partial void OnPropertyChanging(String propertyName)
{
    PropertyChanging?.Invoke(this, new PropertyChangingEventArgs(propertyName));
}
```

Now, everytime an observable property is set, you may react to the change in your partial method implementation.
